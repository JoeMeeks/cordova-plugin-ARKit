<!DOCTYPE html>
<html lang="en">
	<head>
		<title>ios version</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
    </style>
    <base href="./">
	</head>

	<body>
		<script src="js/three.min.js"></script>

		<script src="js/MTLLoader.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/FBXLoader.js"></script>
		<script src="js/OrbitControls.js"></script>

		<script src="js/ModelLoader.js"></script>

		<script>
			function fitCameraToObject(camera, object, controls, offset = 2) {
				const boundingBox = new THREE.Box3();
				boundingBox.setFromObject(object);
				const centerVector = boundingBox.getCenter(new THREE.Vector3());
				const sizeVector = boundingBox.getSize(new THREE.Vector3());

				// get the max side of the bounding box (fits to width OR height as needed )
				const maxDim = Math.max(sizeVector.x, sizeVector.y, sizeVector.z);
				const fov = camera.fov * (Math.PI / 180);
				let cameraZ = Math.abs(maxDim / 2 / Math.sin(fov / 2));
				cameraZ *= offset; // zoom out a little so that objects don't fill the screen

				camera.position.z = cameraZ;

				const minZ = boundingBox.min.z;
				const cameraToFarEdge = (minZ < 0) ? -minZ + cameraZ : cameraZ - minZ;

				camera.far = cameraToFarEdge * 3;
				camera.updateProjectionMatrix();

				if (controls) {
					controls.target = centerVector;
					// prevent camera from zooming out far enough to create far plane cutoff
					controls.maxDistance = cameraToFarEdge * 2;
				} else {
					camera.lookAt(centerVector);
				}
			}
		</script>

		<script>
			document.addEventListener('model', (event) => {
				console.log('was called by iOS');
				addModel(event.detail);
			});

			var lastModelMesh = undefined;
			var container, stats;
			var camera, scene, renderer;
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var controls;
			init();
			animate();

			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				controls = new THREE.OrbitControls( camera );
				controls.update();
		
				// scene
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 'rgb(158,158,158)' );

				scene.add( camera );

				//Light
				scene.add(new THREE.HemisphereLight(undefined, undefined, 0.7));
    		camera.add(new THREE.PointLight(0xffffff, 0.4))

				//Renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				
				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				renderer.render( scene, camera );
			}

			function onProgress( xhr ) {
				xhr = xhr.currentTarget
				if ( xhr.lengthComputable ) {
					var percentComplete = xhr.loaded / xhr.total * 100;
					console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
				}
			};
			
			async function addModel(detail) {
				if (lastModelMesh) {
					scene.remove(lastModelMesh);
					lastModelMesh = undefined;
				}
				const {scale, position, eulerAngles, modelURL} = detail;
				let { materialURL } = detail;
				const baseUrlSearch = modelURL.match(/.*\//);
				let base = '';
				if (baseUrlSearch && baseUrlSearch.length) {
					base = baseUrlSearch[0];
				}

				const modelURLUpdate = modelURL.replace(base, '');
				if (materialURL) {
					materialURL = materialURL.replace(base, '');
				}
				const extensionPos = modelURLUpdate.search(/(\.[a-z]+)$/);
				const modelType = modelURLUpdate.slice(extensionPos + 1);

				const modelLoader = new ModelLoader(base);
				const options = {
        	modelUrl: modelURLUpdate,
        	modelType: modelType,
        	textureUrl: materialURL
      	};
				const model = await modelLoader.load(options, onProgress.bind(this));
				lastModelMesh = model;
				fitCameraToObject(camera, model, controls, 1);
				scene.add(model);
			}
		</script>

	</body>
</html>
